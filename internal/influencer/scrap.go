package influencer

import (
	"encoding/json"
	"errors"
	"sort"
	"time"

	"github.com/boltdb/bolt"
	"github.com/swayops/sway/config"
	"github.com/swayops/sway/internal/common"
	"github.com/swayops/sway/internal/templates"
	"github.com/swayops/sway/misc"
	"github.com/swayops/sway/platforms/facebook"
	"github.com/swayops/sway/platforms/instagram"
	"github.com/swayops/sway/platforms/twitter"
	"github.com/swayops/sway/platforms/youtube"
)

type Scrap struct {
	Id           string `json:"id,omitempty"`
	EmailAddress string `json:"email,omitempty"`

	FacebookID  string `json:"facebookID,omitempty"`
	InstagramID string `json:"instagramID,omitempty"`
	TwitterID   string `json:"twitterID,omitempty"`
	YouTubeID   string `json:"youtubeID,omitempty"`

	// URL links to their account generated by postScrap
	FacebookURL  string `json:"facebookUrl,omitempty"`
	InstagramURL string `json:"instagramUrl,omitempty"`
	TwitterURL   string `json:"twitterUrl,omitempty"`
	YouTubeURL   string `json:"youtubeUrl,omitempty"`

	// Filled by admin
	Geo        *misc.GeoRecord `json:"geo,omitempty"`
	Gender     string          `json:"gender,omitempty"`
	Categories []string        `json:"categories,omitempty"`

	// Timestamp for each time we send this person an email
	SentEmails []*Email `json:"sentEmails,omitempty"`
}

type Email struct {
	Campaigns []string `json:"campaigns,omitempty"`
	Timestamp int32    `json:"ts,omitempty"`
}

var ErrClient = errors.New("Mail client inactive!")

func (sc *Scrap) Email(campaigns *common.Campaigns, sDb, budgetDb *bolt.DB, cfg *config.Config) error {
	// Depending on the emails they've gotten already..
	// send them a follow up email

	// Don't send emails to scraps who've already done max
	if len(sc.SentEmails) >= 3 {
		return nil
	}

	ordered := sc.GetAvailableDeals(campaigns, budgetDb, cfg)
	if len(ordered) == 0 {
		return nil
	}

	if cfg.ReplyMailClient() == nil {
		return ErrClient
	}

	var name string
	if sc.TwitterID != "" {
		name = sc.TwitterID
	} else if sc.InstagramID != "" {
		name = sc.InstagramID
	} else if sc.YouTubeID != "" {
		name = sc.YouTubeID
	} else if sc.FacebookID != "" {
		name = sc.FacebookID
	}

	var sentTs int32
	if len(sc.SentEmails) == 0 {
		if !cfg.Sandbox {
			email := templates.ScrapFirstEmail.Render(map[string]interface{}{"Name": name})
			if resp, err := cfg.ReplyMailClient().SendMessage(email, "Hey", sc.EmailAddress, name,
				[]string{""}); err != nil || len(resp) != 1 || resp[0].RejectReason != "" {
				return ErrEmail
			}
		}
		sentTs = int32(time.Now().Unix())
	} else if len(sc.SentEmails) == 1 {
		// Send second email if it's been more than 26 hours
		// CHECK WITH NICK ON THIS DELAY
		if !misc.WithinLast(sc.SentEmails[0].Timestamp, 26) {
			if !cfg.Sandbox {
				email := templates.ScrapDealOne.Render(map[string]interface{}{"Name": name, "deal": OrderedDeals(ordered)})
				if resp, err := cfg.ReplyMailClient().SendMessage(email, "A few brands currently requesting you", sc.EmailAddress, name,
					[]string{""}); err != nil || len(resp) != 1 || resp[0].RejectReason != "" {
					return ErrEmail
				}
			}
			sentTs = int32(time.Now().Unix())
		}
	} else if len(sc.SentEmails) == 2 {
		// Send third email if it's been more than 14 days
		// CHECK WITH NICK ON THIS DELAY
		if !misc.WithinLast(sc.SentEmails[1].Timestamp, 24*14) {
			if !cfg.Sandbox {
				email := templates.ScrapDealTwo.Render(map[string]interface{}{"Name": name, "deal": OrderedDeals(ordered)})
				if resp, err := cfg.ReplyMailClient().SendMessage(email, "Influencer booking", sc.EmailAddress, name,
					[]string{""}); err != nil || len(resp) != 1 || resp[0].RejectReason != "" {
					return ErrEmail
				}
			}
			sentTs = int32(time.Now().Unix())
		}
	}

	// No need to save anything since the email wasn't sent!
	if sentTs == 0 {
		return nil
	}

	var cids []string
	for _, d := range ordered {
		cids = append(cids, d.CampaignId)
	}

	// Save the Scrap if the email was sent!
	if err := sDb.Update(func(tx *bolt.Tx) (err error) {
		sc.SentEmails = append(sc.SentEmails, &Email{Campaigns: cids, Timestamp: sentTs})

		var (
			b []byte
		)
		if b, err = json.Marshal(sc); err != nil {
			return err
		}

		return misc.PutBucketBytes(tx, cfg.Bucket.Scrap, sc.Id, b)
	}); err != nil {
		return err
	}
	return nil
}

func (sc *Scrap) GetAvailableDeals(campaigns *common.Campaigns, budgetDb *bolt.DB, cfg *config.Config) []*common.Deal {
	tmpInf := &Influencer{
		Geo:        sc.Geo,
		Gender:     sc.Gender,
		Categories: sc.Categories,
	}

	if sc.TwitterID != "" {
		tmpInf.Twitter = &twitter.Twitter{Id: sc.TwitterID}
	}

	if sc.InstagramID != "" {
		tmpInf.Instagram = &instagram.Instagram{UserName: sc.InstagramID}
	}

	if sc.YouTubeID != "" {
		tmpInf.YouTube = &youtube.YouTube{UserName: sc.YouTubeID}
	}

	if sc.FacebookID != "" {
		tmpInf.Facebook = &facebook.Facebook{Id: sc.TwitterID}
	}

	deals := tmpInf.GetAvailableDeals(campaigns, budgetDb, "", nil, false, cfg)

	ordered := OrderedDeals(deals)
	sort.Sort(ordered)

	if len(ordered) > 5 {
		ordered = ordered[0:5]
	}
	return ordered
}
